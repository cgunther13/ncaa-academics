----
title: "STAT 230 Final Project"
author: "Christoph, Carol, Chris"
date: "4/8/2017"
output: html_document
 ----
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 2015 Yellow Taxi Trip Data - NYC Open Data
https://data.cityofnewyork.us/Transportation/2015-Yellow-Taxi-Trip-Data/ba8s-jw6u

"This dataset includes trip records from all trips completed in yellow taxis 
in NYC from January to June in 2015.  Records include fields capturing pick-up 
and drop-off dates/times, pick-up and drop-off locations, trip distances, 
itemized fares, rate types, payment types, and driver-reported passenger counts. 
The data used in the attached datasets were collected and provided to the NYC 
Taxi and Limousine Commission (TLC) by technology providers authorized under the 
Taxicab Passenger Enhancement Program (TPEP). The trip data was not created by 
the TLC, and TLC makes no representations as to the accuracy of these data." 
(from NYC Open Data)

This dataset is huge (146,087,462 rows and 5GB), and too big for our computers 
to work with, so we decided to load in data for 1 day. We chose May 6, for no 
reason in partiocular, except that it is a non-holiday weekday. This was still
a huge amount of data however, so we filtered it further by selecting only the 
rides where passengers paid with a credit card (because these are the only rides
with tip data, which we are interested in exploring), and then took a random 10%
of the rides.


### Variables
* `dropoff_datetime`: date and time when meter was disengaged   
* `dropoff_latitude`: latitude where the meter was disengaged
* `dropoff_longitude`: longitude where the meter was disengaged
* `extra`: Miscellaneous extras and surcharges (0 = no charge, 0.5 = $0.50 rush 
           hour charge, 1 = $1 overnight charge)
* `fare_amount`: time-and-distance fare calculated by the meter
* `mta_tax`: $0.50 tax on taxi rides        
* `passenger_count`: number of passengers in the vehicle
* `payment_type`: how the passenger paid for the trip. Note: Always 1 (credit 
                  card) in the subset of the data we are analyzing. Only about 
                  1/3 of the data was not 1
* `pickup_datetime`: date and time when meter was engaged   
* `pickup_latitude`: latitude where the meter was engaged   
* `pickup_longitude`: longitude where the meter was engaged   
* `rate_code`: final rate code in effect at the end of the trip (1 = Standard 
               rate, 2 = JFK, 3 = Newark 4 = Nassau or Westchester, 5 = 
               Negotiated Fare, 6 = Group Ride)       
* `store_and_fwd_flag`: whether the trip record was held in vehicle memory 
                        before sending to the vendor because the vehicle did not 
                        have a connection to the server (Y = yes, N = no)
* `tip_amount`: tip paid. Note: Only calculated for credit card tips      
* `tolls_amount`: total amount of all tolls paid in the trip
* `total_amount`: total amount charged to passengers (fare + tip + extra + 
                  mta_tax)
* `trip_distance`: elapsed trip distance in miles
* `vendor_id`: technology vendor that provided the record (1 = Creative Mobile 
               Technologies, 2 = VeriFone)

## Suspicious Values
`dropoff_latitude`, `dropoff_longitude`, `pickup_latitude`, `pickup_longitude`
Some latitude and longitude values are 0 (which would be). We will leave them
in for most of the analysis, expect for things dealing directly with location,
We believe, based on looking at these rows, that the 0s are due to the GPS
malfunctioning, but the rest of the data is still valid.
In other cases, pickup and dropoff location are the same, which may be due to a 
passenger making a last minute decision to not take a taxi for whatever reason. 
We removed these in any analysis/plots that have to do with position.

`fare_amount`
There were 2 rows in which `fare_amount` was 0. We removed these rows.

`passenger_count`
There were 6 rows in which `passenger_count` was 0. We removed these rows.

`trip_distance`
There were 80 trips in which trip_distance = 0. We removed these rows.

### Research Questions
We are particularly interested in exploring 3 features of this taxi trips 
dataset: time (`dropoff_datetime` and `pickup_datetime`), location 
(`dropoff_latitude`, `dropoff_longitude`, `pickup_latitude`, and
`pickup_longitude`), and payments, specifically tips (`tip_amount`). 

  * What factors predict how much (as a percentage of their total fare) a person 
    tips?
    * Do they tip more during the holidays? Do they tip more if there are more 
    people in the car (perhaps due to social pressure)? 
    * We will do an all-subsets regression, as well as explore interaction 
    effects.
  * How does the number of passengers influence the ride?
    * For example, tip, distance, pickup/dropoff locations?
  * What are the most popular pickup and drop off locations in New York? 
    * At what times are they most popular? 
    * We will look at specific locations (ie: Times Square/Grand Central, Statue
    of Liberty ferry terminal, Wall Street, etc...) as well as the top 10 most 
    popular ones from the data.
    * At a local level, which directions are taxis traveling on average at 
    different times of the day? 
      * For example, is there a net movement into the city in the mornings and a
      net movement out of the city in the evenings?
    * Are there any locations where there are more drop offs than pickups or 
    vice versa. 
    * For example, we hypothesize that people may take more taxis to JFK than 
    from JFK, because of more clear signage at JFK directing people to use 
    public transportation to reach the city). 
  * What is the average speed of taxis depending on the time of day and region 
  of the city? 


### Code

Read in 2015 Yellow Taxi data through Socrata API for May 6, 2015
(Commented out because it takes a long time to run, and we saved the data we 
need once in taxi_data.csv)
```{r}
#library("RSocrata")
#taxi <- read.socrata("https://data.cityofnewyork.us/resource/2yzn-sicd.json?$where=pickup_datetime between #'2015-05-06T00:00:00.000' and '2015-05-07T00:00:00.000'&payment_type=1")

# Random 10% of rows
#set.seed(230)
#randoms <-sample(1:nrow(taxi), 28857)
#taxi2 <- taxi[randoms,]

#write.csv(taxi2, "taxi_data.csv", row.names = FALSE)
```

Read in smaller subset of taxi data
```{r}
taxi <- read.csv("taxi_data.csv", as.is = TRUE)
```

## Libraries

```{r}
library(dplyr)
library(ggplot2)
library(leaps)
library(ggmap)
library(mapproj)
```

## Cleaning

Create `tip_pct`
```{r}
taxi <- taxi %>% mutate(tip_pct = (tip_amount / fare_amount) * 100)

# Remove observation where tip_pct > 100
taxi <- taxi[-c(which(taxi$tip_pct == "NaN"), which(taxi$tip_pct == "Inf")),]
taxi <- taxi[taxi$tip_pct <= 100,]
```

Create `pickup_hour` and `dropoff_hour`
```{r}
taxi$pickup_hour <- substr(taxi$pickup_datetime, 12, 13)
taxi$pickup_hour <- as.numeric(taxi$pickup_hour)
taxi$dropoff_hour <- substr(taxi$dropoff_datetime, 12, 13)
taxi$dropoff_hour <- as.numeric(taxi$dropoff_hour)
```

Remove `trip_distance` = 0
```{r}
taxi <- taxi[!(taxi$trip_distance == 0),]
```

Remove `passenger_count` = 0 and create factor variable for passenger count
```{r}
taxi <- taxi[taxi$passenger_count > 0,]
factor_passengers <- as.factor(taxi$passenger_count)
```

## Plot of `pct_tip` by `passenger_count`

```{r}
ggplot(taxi, aes(x = factor_passengers, y = tip_pct)) + 
  geom_boxplot() +
  labs(title = "Percentage Tipped by Number of Passengers", x = 
    "Number of Passengers", y = "Percentage Tipped")
```

## All-Subsets Regression to Predict `tip_pct`

```{r}
r1 = regsubsets(tip_pct ~ pickup_hour + pickup_latitude + pickup_longitude +  
                  dropoff_hour + dropoff_latitude + dropoff_longitude + 
                  fare_amount + passenger_count + trip_distance + tolls_amount + 
                  extra + vendor_id, data = taxi, nvmax = 10)
r1s <- summary(r1)
r1s$which
plot(r1s$rsq, main = "R-squareds of Models with Increasingly More Variables", 
     ylab = "R-sqaured")

plot(r1s$cp, main = "Mallows' Cp of Models with Increasingly More Variables", 
     ylab = "Cp")
plot(r1, scale="Cp", main = "Most Important Predictors in Different Size Models")

which.min(r1s$cp)
bestwhich <- r1s$which[which.min(r1s$cp),]
best_vars <- names(bestwhich[bestwhich == TRUE])
best_vars <- best_vars[-1]
best_vars
```

We decided to perform an all-subsets regression to predict `tip_pct` in order to
hone in on the strogest predictors of `tip_pct`. Obviously, we decided to leave
`tip_amount` and `fare_amount` out of the list of predictors, because they are 
included in the formula that determines `tip_pct` and would therefore by 
trivially correlated. 

The first plot shows the different r-squared values in models with increasingly
more predictors. As we expect, the r-squared value increases as we add more 
predictors, but flattens out around 5%. This is a very low r-squared value.

The second plot shows the different values of Mallow's Cp in models with 
increasignly more predictors. Here, Cp drops until 6, and then levels out 
at about 0.

Finally, the third, culminating plot uses Mallow's Cp to determine which set of 
variables is the "best" (most efficient combination of variables) for predicting 
`pct_tip`. The top row shows this best model, and shows that the most important 
variables for predicting `pct_tip` are `pickup_hour`, `fare_amount`, 
`tolls_amount`, and `extra`. Thus, we can build a model using these predictors:

```{r}
mbest <- lm(tip_pct ~ pickup_hour + fare_amount + tolls_amount + extra, 
            data = taxi)
summary(mbest)
```

Thus we see that `extra` has the largest effect on the amount a passenger 
decides to tip, on average giving a 1.77% higher tip for a $1 increase in extra 
fees. We hypothesize that this could be because the passenger feels like the 
driver had to work extra hard to compelte a trip in rush hour or overnight, and 
therefore the passenger wants to reward the driver for going the extra mile.

`toll_amount` also has a fairly large impact, as on average passengers give a 1%
higher tip for a $1 increase in tolls. At first we thought that the passenger 
felt a duty to repay the toll in the tip, but it turns out that the passenger is
already responsible for the toll, so they are actually paying even more. This 
seems counterintuitive, but could be due to the passenger wanting to repay the
driver for going through the log jam at a toll booth. 


## Location Plots

```{r}
#remove rows with abnormal dropoff longitudes
#ggplot(taxi, aes(x = dropoff_longitude, y = dropoff_latitude)) + geom_point()
library(ggmap)
library(mapproj)

MAXLAT <- 40.85
MINLAT <- 40.675
MAXLONG <- -73.85
MINLONG <- -74.1
pos <- filter(taxi, pickup_longitude < MAXLONG, pickup_longitude > MINLONG, pickup_latitude < MAXLAT, pickup_latitude > MINLAT)


map <- get_map(location = c(MINLONG,MINLAT, MAXLONG, MAXLAT), source = "stamen", maptype = "watercolor")
ggmap(map) + geom_point(aes(x = pickup_longitude, y = pickup_latitude), data = pos, alpha = 0.3, col = "red")
```

```{r}
GRIDLENGTH <- 100 # Number of Columns in Grid
long_unit <- (MAXLONG - MINLONG)/GRIDLENGTH
lat_unit <- (MAXLAT - MINLAT)/GRIDLENGTH

lat_bound <- seq(from = MINLAT, to = MAXLAT, by = lat_unit)
long_bound <- seq(from = MINLONG, to = MAXLONG, by = long_unit)

plot(pos$pickup_latitude ~ pos$pickup_longitude)
for(i in 1:GRIDLENGTH) {
  abline(h = lat_bound[i], lwd = 1,  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))
  abline(v = long_bound[i], lwd = 1, col = rgb(0.1, 0.1, 0.1, alpha = 0.3))
}

```

```{r}
pos$lat_region <- rep(NA, nrow(pos))
pos$long_region <- rep(NA, nrow(pos))
length(lat_bound)
  for(i in 1:nrow(pos)) {
    for(k in 1:(GRIDLENGTH)){
      if(pos$pickup_latitude[i] >= lat_bound[k] & pos$pickup_latitude[i] < lat_bound[k + 1]){         pos$lat_region[i] <- k
        break
      } # end if
    } # end for k
    for(k in 1:(GRIDLENGTH)){
      if(pos$pickup_longitude[i] >= long_bound[k] & pos$pickup_long[i] < long_bound[k + 1]) {
        pos$long_region[i] <- k
        break
      }# end if
    }# end for k
  }# end for i

```

```{r}
grouped <- group_by(pos, lat_region, long_region) %>% summarize(lat_dir = mean(dropoff_latitude - pickup_latitude), long_dir = mean(dropoff_longitude - pickup_longitude), count = n())


grouped$lat_min = rep(NA, nrow(grouped))
grouped$lat_max = rep(NA, nrow(grouped))
grouped$long_min = rep(NA, nrow(grouped))
grouped$long_max = rep(NA, nrow(grouped))

for(i in 1:nrow(grouped)) {
  grouped$lat_min[i] <- lat_bound[grouped$lat_region[i]]
  grouped$lat_max[i] <- lat_bound[grouped$lat_region[i] + 1]
  grouped$long_min[i] <- long_bound[grouped$long_region[i]]
  grouped$long_max[i] <- long_bound[grouped$long_region[i] + 1]
}


ggplot(data = grouped, aes(xmin = long_min, xmax = long_max, ymin = lat_min, ymax = lat_max, fill = count)) + geom_rect() + scale_fill_gradient("Number of Rides", low = "red", high = "white")
```

```{r}
#install.packages("rworldmap")
#install.packages("ggmap")
#install.packages("mapproj")
library(ggmap)
library(mapproj)
map <- get_map(location = c(MINLONG,MINLAT, MAXLONG, MAXLAT), source = "stamen", maptype = "watercolor")

ggmap(map)+ geom_rect(aes(x = long_min, y = long_max, xmin = long_min, xmax = long_max, ymin = lat_min, ymax = lat_max, fill = count), data = grouped) + scale_fill_gradientn(colors = rainbow(7)) + labs(title = "Number of Taxi Pickups by Region", x = expression(italic("Longitude")~"(degrees)"),y = expression(italic("Latitude")~"(degrees)"))
```


Direction of Motion Plot

```{r}
#remove rows with abnormal dropoff longitudes

MAXLAT <- 40.85
MINLAT <- 40.675
MAXLONG <- -73.85
MINLONG <- -74.1
pos <- filter(taxi, pickup_longitude < MAXLONG, pickup_longitude > MINLONG, pickup_latitude < MAXLAT, pickup_latitude > MINLAT) # selects all taxi rides whose pickup was within the specified region. Stores these rides to a new data frame 'pos'
pos <- filter(pos, dropoff_longitude != 0, dropoff_latitude!= 0)
pos <- filter(pos, dropoff_longitude != pickup_longitude, dropoff_latitude != pickup_latitude)

map <- get_map(location = c(MINLONG,MINLAT, MAXLONG, MAXLAT), source = "stamen", maptype = "watercolor")
ggmap(map) + geom_point(aes(x = pickup_longitude, y = pickup_latitude), data = pos, alpha = 0.3, col = "red") # plots pickup sites
```

```{r}
GRIDLENGTH <- 25 # Number of Columns in Grid
long_unit <- (MAXLONG - MINLONG)/GRIDLENGTH
lat_unit <- (MAXLAT - MINLAT)/GRIDLENGTH

lat_bound <- seq(from = MINLAT, to = MAXLAT, by = lat_unit)
long_bound <- seq(from = MINLONG, to = MAXLONG, by = long_unit)

plot(pos$pickup_latitude ~ pos$pickup_longitude)
for(i in 1:GRIDLENGTH) {
  abline(h = lat_bound[i], lwd = 1,  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))
  abline(v = long_bound[i], lwd = 1, col = rgb(0.1, 0.1, 0.1, alpha = 0.3))
} # plots grid, as divided
```


```{r}
# Identifies what grid squares each pickup location is located in. Lat_region gives vertical grid number. Long_region gives horizontal grid number

pos$lat_region <- rep(NA, nrow(pos)) 
pos$long_region <- rep(NA, nrow(pos))
length(lat_bound)
  for(i in 1:nrow(pos)) {
    for(k in 1:(GRIDLENGTH)){
      if(pos$pickup_latitude[i] >= lat_bound[k] & pos$pickup_latitude[i] < lat_bound[k + 1]){         pos$lat_region[i] <- k
        break
      } # end if
    } # end for k
    for(k in 1:(GRIDLENGTH)){
      if(pos$pickup_longitude[i] >= long_bound[k] & pos$pickup_long[i] < long_bound[k + 1]) {
        pos$long_region[i] <- k
        break
      }# end if
    }# end for k
  }# end for i
```

```{r}
head(pos)
```

```{r}
SIZEFACTOR = 0.01 # Desired Magnitude of Direction Arrows
pos <- mutate(pos, lat_dir = (dropoff_latitude - pickup_latitude), long_dir = (dropoff_longitude - pickup_longitude))

pos <- mutate(pos, lat_dir_scaled = lat_dir * SIZEFACTOR/sqrt(lat_dir^2 + long_dir^2), long_dir_scaled = long_dir * SIZEFACTOR /sqrt(lat_dir^2 + long_dir^2))
# NaN results for those rides where pickup and dropoff locations are equal.
```

```{r}
grouped <- group_by(pos, lat_region, long_region) %>% summarize(lat_dir_avg = mean(lat_dir_scaled, na.rm = TRUE), long_dir_avg = mean(long_dir_scaled, na.rm =TRUE), count = n())

grouped$lat_min = rep(NA, nrow(grouped))
grouped$lat_max = rep(NA, nrow(grouped))
grouped$long_min = rep(NA, nrow(grouped))
grouped$long_max = rep(NA, nrow(grouped))

for(i in 1:nrow(grouped)) {
  grouped$lat_min[i] <- lat_bound[grouped$lat_region[i]]
  grouped$lat_max[i] <- lat_bound[grouped$lat_region[i] + 1]
  grouped$long_min[i] <- long_bound[grouped$long_region[i]]
  grouped$long_max[i] <- long_bound[grouped$long_region[i] + 1]
}

grouped <- mutate(grouped, avg_lat = (lat_max + lat_min)/2, avg_long = (long_max + long_min)/2)
```


```{r}
ggplot(data = grouped, aes(xmin = long_min, xmax = long_max, ymin = lat_min, ymax = lat_max, fill = count)) + geom_rect() + scale_fill_gradient("Number of Rides", low = "red", high = "white")
```


```{r}
ggmap(map) + geom_segment(aes(x = avg_long, xend = (avg_long + long_dir_avg), y = avg_lat, yend = (avg_lat + lat_dir_avg), fill = "black"), data = grouped, arrow = arrow(length=unit(0.15,"cm"), ends="first", type = "closed")) + labs(title = "Direction of Motion by Region", x = expression(italic("Longitude")~"(degrees)"),y = expression(italic("Latitude")~"(degrees)"))
```
